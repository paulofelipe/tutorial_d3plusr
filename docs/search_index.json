[
["index.html", "Introdução ao pacote D3plusR 1 Visão Geral 1.1 Sobre o D3plus e o D3plusR 1.2 Instalando o pacote 1.3 Pacotes adicionais necessário para o tutorial 1.4 Opções das funções 1.5 Dados utilizados nos exeplos", " Introdução ao pacote D3plusR Paulo Felipe Alencar de Oliveira 22/05/2017 1 Visão Geral 1.1 Sobre o D3plus e o D3plusR O pacote D3plusR é um widget criado a partir do framework fornecido pelo pacote htmlwidgets. De forma resumida, esse pacote fornece uma estrutura em que se torna possível a incorporação de bibliotecas de visualizações desenvolvidas em javascript em análises desenvolvidas com o R. Como o nome do pacote indica, esse pacote usa a biblioteca D3plus que, por sua vez, é construída em cima da biblioteca mais genérica D3. A criação de visualizações diretamente com D3 pode ser um pouco desafiadora no início. Dessa forma, os autores do pacote D3plus criaram um conjunto de visualizações pré-definidas em que é possível criar, de maneira simples, visualizações efetivas e com uma qualidade final consideravelmente alta. 1.2 Instalando o pacote O pacote ainda não possui uma versão 1.0. A sua versão de desenvolvimento está disponível no github. Para instalar, é necessário usar o pacote devtools: devtools::install_github(&#39;paulofelipe/D3plusR&#39;) 1.3 Pacotes adicionais necessário para o tutorial Nos exemplos desse livro, os seguintes pacotes também serão necessários: dplyr jsonlite readxl tidyr 1.4 Opções das funções Na documentação do pacote não estão listadas todas as opções disponíveis para a criação de visualizações. Sugere-se que o usuário utiliza a página disponibilizada pelos autores do D3plus. Opções da biblioteca Com as explicações dos próximos capítulos e os exemplos, ficará mais intuitivo de como usar as opções listadas no link acima. 1.5 Dados utilizados nos exeplos Os dados utilizados nos exemplos estão disponíveis neste link "],
["opcoes-do-d3plus.html", " 2 Opções do D3plus 2.1 Introdução 2.2 Tipos de dados", " 2 Opções do D3plus 2.1 Introdução Como dito no capítulo anterior, as opções do D3plus estão listadas neste link. O D3plus utiliza uma estrutura de métodos encadeados. Os métodos são, por exemplo, .x(), .y() e .color(). É importante que o usuário conheça bem a página de opções e tenha algum conhecimento sobre tipos de dados em JavaScript. Veja na figura abaixo um exemplo de opções para o método .axes() (no D3plusR, d3plusAxes()). Preste atenção em todas as colunas. Opções para o método .axes() Na figura acima, vemos que o método .axes() recebe um objeto que pode ter três pares key/value. No entanto, perceba que a key background recebe um objeto que aceita outras keys/values. Ou seja, um objeto recebendo um objeto. Basicamente, a lógica key/value é e equivalente no R a argumentos/valores. Por exemplo, na biblioteca original, se o usuário quisesse configurar aspectos relativos aos eixos, poderia escrever o seguinte código: .axes({&quot;ticks&quot;: false, &quot;background&quot;: {&quot;color&quot;: &quot;#FFFFFF&quot;, &quot;stroke&quot;: {&quot;width&quot;: 0}}}) No pacote D3plusR, esta disponível a função d3plusAxes(). No entanto, é necessário saber qual estrutura de dados do R replica a estrutura acima. Isto seria feito da seguinte forma: library(D3plusR) library(dplyr) # Inicia uma visualização apenas para apresentar a função d3plusAxes d3 &lt;- d3plus() %&gt;% d3plusAxes(ticks = FALSE, background = list(color = &quot;#FFFFFF&quot;, stroke = list(width = 0))) # Acessando a lista criada d3$x$d3plusAxes ## {&quot;ticks&quot;:false,&quot;mirror&quot;:false,&quot;background&quot;:{&quot;color&quot;:&quot;#FFFFFF&quot;,&quot;stroke&quot;:{&quot;width&quot;:0}}} Como dito no capítulo anterior, o pacote htmlwidgets possibilita o uso de bibliotecas javascript no R. No entanto, é necessário um mecanismo de comunicação entre as duas tecnologias para que os dados do R sejam convertidos para JSON (JavaScript Object Notation). O D3plusR usa pacote jsonlite para conversão de estruturas de dados de R (data.frame, listas, vetores) para json.Na próxima seção, iremos detalhar como cada estrutura de dados do R é convertida em uma estrutura correspondente em JSON. Os argumentos das funções do tipo d3plusMetodo() são agregados em uma lista. Apesar do entendimento dessa seção não ser estritamente necessário para utilização do pacote, o conhecimento sobre JSON, que é uma estrutura de dados de JavaScript, contribuirá para um uso mais completo da ferramenta. Por exemplo, será possível que o usuário entenda os exemplos em JavaScript que estão disponíveis em diversas fontes (página do d3plus, github e grupo no google) e os transcreva mais facilmente para a sintaxe do pacote D3plusR. Assumindo que o leitor já conhece a estrutra básica de dados do R, a próxima seção apresenta as estruturas básicas de JSON’s. 2.2 Tipos de dados Basicamente, os tipos de dados que podem ser passados como opção no D3plus são: number string object (json object) array boolean function null A maioria desses tipos de dados é de fácil entendimento para um usuário de R. No entanto, dois deles podem ser novidades, o array e o object. Por fim, também é possível passar funções em JavaScript. Como isto é um pouco avançado, vamos abstrair essa possibilidade por enquanto. 2.2.1 Array O array é um tipo de dado em JavaScript equivalente a uma simples vetor para o R. Esse tipo de dado tem a seguinte estrutura: var names = [&#39;João&#39;, &#39;José&#39;, &#39;Maria&#39;] No R ele poderia ser criado e convertido para um JSON da seguinte forma: names &lt;- c(&#39;João&#39;, &#39;José&#39;, &#39;Maria&#39;) jsonlite::toJSON(names) ## [&quot;João&quot;,&quot;José&quot;,&quot;Maria&quot;] Ou seja, se o usuário desejar passar somente um array de dados, basta passar um vetor. 2.2.2 Object Para o JSON, object é estrutura de informação composta por um par key/value, devendo ser delimitado por {}. Por exemplo: var my_object = {&quot;model&quot;: &quot;fiat&quot;, &quot;year&quot;: 2015} Em R, faríamos o seguinte: my_object = list(model = &quot;fiat&quot;, year = 2015) jsonlite::toJSON(my_object, auto_unbox = TRUE) ## {&quot;model&quot;:&quot;fiat&quot;,&quot;year&quot;:2015} Usando o fato que cada um data.frame nada mais é uma lista em que cada elemento tem o mesmo comprimento, poderíamos obter um resultado similar a partir de um data.frame: my_object = data.frame(model = &quot;fiat&quot;, year = 2015) jsonlite::toJSON(my_object, auto_unbox = TRUE) ## [{&quot;model&quot;:&quot;fiat&quot;,&quot;year&quot;:2015}] Note que agora o objeto está envolto []. Ou seja, recebemos um array com único objeto. Se tívessemos mais linhas no data.frame teríamos o seguinte resultado: my_object = data.frame(model = c(&quot;fiat&quot;, &quot;chevrolet&quot;), year = c(2015, 2014)) jsonlite::toJSON(my_object, auto_unbox = TRUE) ## [{&quot;model&quot;:&quot;fiat&quot;,&quot;year&quot;:2015},{&quot;model&quot;:&quot;chevrolet&quot;,&quot;year&quot;:2014}] Se o os objetos de um array não possuem as mesmas chaves, é necessário usar lista de listas. Veremos um exemplo no capítulo de elementos de interface para o usuário. 2.2.3 Objeto recebendo objeto E se quiséssemos saber qual é a estrutura de dados em R equivalente a estrutura abaixo? {&quot;value&quot;: &quot;Trade_Value&quot;, &quot;font&quot;: {&quot;size&quot;: 12, &quot;weight&quot;: 900}} No caso, temos um objeto com dois pares key/value, mas o valor da segunda entrada é também um objeto. Dessa forma, faríamos o seguinte: my_object2&lt;- list(value = &quot;Trade_Value&quot;, font = list(size = 12, weight = 900)) jsonlite::toJSON(my_object2, auto_unbox = TRUE) ## {&quot;value&quot;:&quot;Trade_Value&quot;,&quot;font&quot;:{&quot;size&quot;:12,&quot;weight&quot;:900}} "],
["primeiro-exemplo.html", " 3 Primeiro Exemplo 3.1 Criando uma simples visualização de barras", " 3 Primeiro Exemplo 3.1 Criando uma simples visualização de barras Neste primeiro exemplo, iremos replicar o exemplo disponibilizado pelo desenvolvedores do pacote neste link. O código original é o seguinte: &lt;!doctype html&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;//d3plus.org/js/d3.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//d3plus.org/js/d3plus.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;viz&quot;&gt;&lt;/div&gt; &lt;script&gt; var data = [ {&quot;year&quot;: 1991, &quot;name&quot;:&quot;alpha&quot;, &quot;value&quot;: 15}, {&quot;year&quot;: 1991, &quot;name&quot;:&quot;beta&quot;, &quot;value&quot;: 10}, {&quot;year&quot;: 1991, &quot;name&quot;:&quot;gamma&quot;, &quot;value&quot;: 5}, {&quot;year&quot;: 1991, &quot;name&quot;:&quot;delta&quot;, &quot;value&quot;: 50}, {&quot;year&quot;: 1992, &quot;name&quot;:&quot;alpha&quot;, &quot;value&quot;: 20}, {&quot;year&quot;: 1992, &quot;name&quot;:&quot;beta&quot;, &quot;value&quot;: 10}, {&quot;year&quot;: 1992, &quot;name&quot;:&quot;gamma&quot;, &quot;value&quot;: 10}, {&quot;year&quot;: 1992, &quot;name&quot;:&quot;delta&quot;, &quot;value&quot;: 43}, {&quot;year&quot;: 1993, &quot;name&quot;:&quot;alpha&quot;, &quot;value&quot;: 30}, {&quot;year&quot;: 1993, &quot;name&quot;:&quot;beta&quot;, &quot;value&quot;: 40}, {&quot;year&quot;: 1993, &quot;name&quot;:&quot;gamma&quot;, &quot;value&quot;: 20}, {&quot;year&quot;: 1993, &quot;name&quot;:&quot;delta&quot;, &quot;value&quot;: 17}, {&quot;year&quot;: 1994, &quot;name&quot;:&quot;alpha&quot;, &quot;value&quot;: 60}, {&quot;year&quot;: 1994, &quot;name&quot;:&quot;beta&quot;, &quot;value&quot;: 60}, {&quot;year&quot;: 1994, &quot;name&quot;:&quot;gamma&quot;, &quot;value&quot;: 25}, {&quot;year&quot;: 1994, &quot;name&quot;:&quot;delta&quot;, &quot;value&quot;: 32} ] var visualization = d3plus.viz() .container(&quot;#viz&quot;) .data(data) .type(&quot;bar&quot;) .id(&quot;name&quot;) .x(&quot;year&quot;) .y(&quot;value&quot;) .draw() &lt;/script&gt; O nosso interesse é na parte que está dentro da tag &lt;script&gt;. Perceba que foi criar um objeto chamado data que é um array de objetos. Esses objetos têm as seguintes chaves (keys) year,name e value com seus respectivos valores (values). Assim, vamos criar a estrutura de dados no R que após ser convertida irar gerar um objeto igual ao criado acima: data &lt;- data.frame(year = c(1991, 1991, 1991, 1991, 1992, 1992, 1992, 1992, 1993, 1993, 1993, 1993, 1994, 1994, 1994, 1994), name = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;), value = c(15, 10, 5, 50, 20, 10, 10, 43, 30, 40, 20, 17, 60, 60, 25, 32)) Não precisamos nos preocupar com o jsonlite agora, pois o pacote D3plusR é faz essa conversão. A segunda parte do código (visualization) cria a visualização. Cada método é representado por um método (.metodo()). Ou seja, .data() refere-se ao método de dados, .type() controla o tipo de gráfico, .size() controla opções refente a codificação visual de tamanho etc. De maneira geral, o pacote D3plusR fornece uma função para cada método desse. Por exemplo, o método .size() é utilizado a partir da função d3plusSize(). Vale ressaltar que alguns métodos mais comuns e que não usam muitas opções já estão disponíveis na função d3plus(), que é a função utilizada para inicializar a visualização. Por exemplo, ao invés de usar d3plusData(), pode-se passar diretamente o data.frame no argumento data. O mesmo vale para type e id. A função também fornece uma funcionalidades extras que serão descritas mais a frente, como a possibilidade de uso de um dicionário e definição de características de moeda. library(D3plusR) library(jsonlite) library(dplyr) d3plus(data = data, type = &quot;bar&quot;, id = &quot;name&quot;, height = 500, width = &quot;100%&quot;) %&gt;% d3plusX(&quot;year&quot;) %&gt;% d3plusY(&quot;value&quot;) O id é um pouco específico do pacote. Ele serve de identificador de cada ponto. No caso da visualização acima, cada name é um identificador daquele ponto. No exemplo acima, name poderia ser o nome de um país. A variável value é usada para definir o valor de y de cada barra e year informa o valor de x. O entendimento do id fica mais claro com os demais exemplos. Veja também a lógica de encadeamento com o %&gt;% que replica uma estrutura similar ao código original. Para finalizar esse capítulo, vamos apenas incluir um título: d3plus(data = data, type = &quot;bar&quot;, id = &quot;name&quot;, height = 500, width = &quot;100%&quot;) %&gt;% d3plusX(&quot;year&quot;) %&gt;% d3plusY(&quot;value&quot;) %&gt;% d3plusTitle(value = &quot;Minha primeira visualização com D3plusR&quot;, sub = &quot;Um simples gráfico de barras&quot;, font = list(size = 22, weight = 900)) O importante aqui é perceber que: Um único valor sem o nome do argumento, como em d3plusY(&quot;value&quot;), é o equivalente a d3plusY(value = &quot;value&quot;) d3plusY(value = &quot;value&quot;) Se forem passados vários argumentos é preciso nomeá-los: d3plusTitle(value = &quot;Título&quot;, sub = &quot;Subtítulo&quot;) Se um argumento puder receber opções, essas opções, em regra, serão passadas por meio de uma lista nomeada: d3plusTitle(value = &quot;Minha primeira visualização com D3plusR&quot;, sub = &quot;Um simples gráfico de barras&quot;, font = list(size = 22, weight = 900)) "],
["barras.html", " 4 Barras 4.1 Dados 4.2 Criando a visualização 4.3 Adicionando outros elementos 4.4 Incluindo um dicionário 4.5 Estrutura Hierárquica", " 4 Barras 4.1 Dados Aqui serão usados os dados de exportações e importações brasileiras anuais de 1989 a 2016. 4.2 Criando a visualização library(dplyr) library(D3plusR) dados &lt;- read.csv(&#39;dados/exp_imp_brasil.csv&#39;) d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, label = &quot;Ano&quot;) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, label = &quot;Valor FOB&quot;) Alguns pontos que devem ser ressaltados do gráfico acima: o D3plus automaicamente aplica uma formação para os números, incluindo símbolos para Bilhões, milhões e milhares; perceba que a ordem das barras não é respeitada, sempre o menos valor vem primeiro. O primeiro problema pode ser resolvido com os argumentos number_text, currency, currency_var, percent_var e noformat_number_var. Basicamente, iremos dizer quais são os textos que devem aparecer para bilhões, milhões e milhares. currency define o símbolo da moeda que desejamos adiconar antes do número das variáveis que definirmos como variáveis de moeda, currency_var indica o nome das variáveis de moeda, percent_var indica o nome das variáveis que são percentuais e noformat_number_var indica quais variáveis devem apresentar o número na sua forma original. d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, currency = &quot;US$&quot;, number_text = c(&quot;Mil&quot;, &quot;Milhão&quot;, &quot;Milhões&quot;, &quot;Bilhão&quot;, &quot;Bilhões&quot;), currency_var = &quot;VL_FOB&quot;, noformat_number_var = &quot;CO_ANO&quot;) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, grid = FALSE, persist = list(position = TRUE)) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, grid = TRUE) %&gt;% d3plusAxes(ticks = FALSE, background = list(color = &quot;#FFFFFF&quot;, stroke = list(width = 0))) 4.3 Adicionando outros elementos d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, currency = &quot;US$&quot;, number_text = c(&quot;Mil&quot;, &quot;Milhão&quot;, &quot;Milhões&quot;, &quot;Bilhão&quot;, &quot;Bilhões&quot;), currency_var = &quot;VL_FOB&quot;, noformat_number_var = &quot;CO_ANO&quot;) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, grid = FALSE, persist = list(position = TRUE)) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, grid = TRUE) %&gt;% d3plusAxes(ticks = FALSE, background = list(color = &quot;#FFFFFF&quot;, stroke = list(width = 0))) %&gt;% d3plusTime(&quot;CO_ANO&quot;) %&gt;% d3plusTooltip(c(&quot;CO_ANO&quot;, &quot;VL_FOB&quot;)) %&gt;% d3plusColor(&quot;TIPO&quot;, scale = c(&quot;#3C8BE6&quot;, &quot;#6E8749&quot;)) %&gt;% d3plusLegend(value = TRUE, data = FALSE) Para que a ordem das barras guarde correspondência com a ordem que aparece nos dados, é preciso que a variável responsável pelo eixo x seja do tipo character. dados$CO_ANO &lt;- as.character(dados$CO_ANO) dados$TIPO &lt;- as.character(dados$TIPO) d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, currency = &quot;US$&quot;, number_text = c(&quot;Mil&quot;, &quot;Milhão&quot;, &quot;Milhões&quot;, &quot;Bilhão&quot;, &quot;Bilhões&quot;), currency_var = &quot;VL_FOB&quot;, noformat_number_var = &quot;CO_ANO&quot;) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, grid = FALSE, persist = list(position = TRUE)) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, grid = TRUE) %&gt;% d3plusAxes(ticks = FALSE, background = list(color = &quot;#FFFFFF&quot;, stroke = list(width = 0))) %&gt;% d3plusTime(&quot;CO_ANO&quot;) %&gt;% d3plusTooltip(c(&quot;CO_ANO&quot;, &quot;VL_FOB&quot;)) %&gt;% d3plusColor(&quot;TIPO&quot;, scale = c(&quot;#6E8749&quot;, &quot;#3C8BE6&quot;)) %&gt;% d3plusLegend(value = TRUE, data = FALSE, order = list(sort = &quot;desc&quot;), size = 35) 4.4 Incluindo um dicionário A função d3plus() tem um argumento que pode ser receber um dicionário (uma lista). Esse dicionário pode ser usado para traduzir nomes de variáveis para textos mais amigáveis, por exemplo. dicionario &lt;- list(VL_FOB = &quot;Valor FOB&quot;, CO_ANO = &quot;Ano&quot;, IMP = &quot;Importações&quot;, EXP = &quot;Exportações&quot;, isolar = &quot;Selecionar&quot;, ocultar = &quot;Esconder&quot;) d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, currency = &quot;US$&quot;, number_text = c(&quot;Mil&quot;, &quot;Milhão&quot;, &quot;Milhões&quot;, &quot;Bilhão&quot;, &quot;Bilhões&quot;), currency_var = &quot;VL_FOB&quot;, noformat_number_var = &quot;CO_ANO&quot;, dictionary = dicionario) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, grid = FALSE, persist = list(position = TRUE)) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, grid = TRUE) %&gt;% d3plusAxes(ticks = FALSE, background = list(color = &quot;#FFFFFF&quot;, stroke = list(width = 0))) %&gt;% d3plusTime(&quot;CO_ANO&quot;) %&gt;% d3plusTooltip(c(&quot;CO_ANO&quot;, &quot;VL_FOB&quot;)) %&gt;% d3plusColor(&quot;TIPO&quot;, scale = c(&quot;#6E8749&quot;, &quot;#3C8BE6&quot;)) %&gt;% d3plusLegend(value = TRUE, data = FALSE, order = list(value = &quot;id&quot;, sort = &quot;asc&quot;), size = 35) 4.5 Estrutura Hierárquica O usuário pode especificar mais de um nível no id. Assim, a visualização criada apresentará os dados no primeiro nível e abrirá o segundo nível a partir de um clique. O nível inicial pode ser escolhido a partir da função d3plusDepth() (sendo o valor 0 para o primerio nível). bra_chn_fat &lt;- read.csv2(&#39;dados/chn_anual_fat.csv&#39;) bra_chn_fat$CO_ANO &lt;- as.character(bra_chn_fat$CO_ANO) head(bra_chn_fat) ## TIPO CO_ANO NO_PAIS NO_FAT_AGREG VL_FOB ## 1 EXPORTA\\xc7\\xd5ES 2006 China Opera\\xe7\\xf5es Especiais 34334619 ## 2 EXPORTA\\xc7\\xd5ES 2006 China Produtos B\\xe1sicos 6213222707 ## 3 EXPORTA\\xc7\\xd5ES 2006 China Produtos Manufaturados 879401653 ## 4 EXPORTA\\xc7\\xd5ES 2006 China Produtos Semimanufaturados 1275409848 ## 5 EXPORTA\\xc7\\xd5ES 2007 China Opera\\xe7\\xf5es Especiais 17476098 ## 6 EXPORTA\\xc7\\xd5ES 2007 China Produtos B\\xe1sicos 7927295420 ## KG_LIQUIDO ## 1 138332 ## 2 95568324143 ## 3 507473057 ## 4 1911374028 ## 5 172164 ## 6 118401572919 d3plus(bra_chn_fat, type = &quot;bar&quot;, id = c(&quot;TIPO&quot;, &quot;NO_FAT_AGREG&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, grid = FALSE, persist = list(position = TRUE)) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, grid = TRUE, stacked = c(TRUE, FALSE)) %&gt;% d3plusDepth(0) %&gt;% d3plusColor(value = &quot;TIPO&quot;, scale = &quot;category10&quot;) "],
["tree-map.html", " 5 Tree map", " 5 Tree map Os dados usados abaixo são das exportações brasileiras para China a partir de 2015, considerando o período parcial até abril, como também o total dos anos de 2015 e 2016. Os dados estão desagregados por fator agregado e principais produtos exportados e importados. library(D3plusR) library(dplyr) dados_chn &lt;- read.csv2(&#39;dados/chn.csv&#39;, stringsAsFactors = FALSE) dados_chn_exp &lt;- dados_chn %&gt;% filter(TIPO == &quot;EXPORTAÇÕES&quot;, PERIODO == &quot;Total&quot;) d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) Para que o d3plus possa mostrar as participações, é necessário que os rótulos (labels) tenham o seu alinhamento vertical definido para o topo. d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) %&gt;% d3plusLabels(value = TRUE, valign = &quot;top&quot;) Agora, vamos definir que o nível de profundidade da visualização é o de produtos e a cor sendo definida pelo fator agregado: d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) %&gt;% d3plusLabels(value = TRUE, valign = &quot;top&quot;) %&gt;% d3plusDepth(1) %&gt;% d3plusColor(value = &quot;NO_FAT_AGREG&quot;) %&gt;% d3plusLegend(value = TRUE, order = list(value = &quot;size&quot;, sort = &quot;desc&quot;)) "],
["geomap.html", " 6 Geomap", " 6 Geomap Há duas possibilidades de se trabalhar com mapas no D3plusR: Importar os dados do mapa usando o pacote jsonlite Indicar o endereço do arquivo A segunda opção não funciona para visualizações que serão geradas diretamente no Viewer do RStudio. Isto ocorre porque o htmlwidget gerado diretamente no RStudio é criado em um arquivo temporário e, por questões de segurança, não tem permissão para acessar arquivos de outras pastas. Nesse caso, deve-se usar a primeira solução. O outro ponto importante é formato do arquivo do mapa. O D3plus precisa de um arquivo no formato topojson. O pacote D3plusR fornece um arquivo para o mapa mundial. A localização desse arquivo pode ser obtida da seguinte forma: library(dplyr) library(D3plusR) mapa &lt;- system.file(&quot;extdata&quot;, &quot;countries.topojson&quot;, package = &quot;D3plusR&quot;) Vamos criar um exemplo usando a primeira opção: # Carregar os dados do mapa # O identificador do mapa é o ISO A3 de cada país mapa &lt;- jsonlite::fromJSON(mapa, simplifyVector = F) # Exportações Brasíleiras de 2015 por Destino data(&quot;bra_exp_2015&quot;) d3plus(data = bra_exp_2015, type = &quot;geo_map&quot;, id = &quot;Partner.ISO&quot;, width = &quot;100%&quot;, height = 500) %&gt;% d3plusCoords(mapa, projection = &quot;equirectangular&quot;) %&gt;% d3plusColor(value = &quot;Trade.Value..US..&quot;) %&gt;% d3plusTooltip(value = c(&quot;Trade.Value..US..&quot;, &quot;Partner.ISO&quot;)) %&gt;% d3plusLabels(FALSE) %&gt;% d3plusText(&quot;Partner&quot;) Utilizando a segunda opção: d3plus(data = bra_exp_2015, type = &quot;geo_map&quot;, id = &quot;Partner.ISO&quot;, width = &quot;100%&quot;, height = 500) %&gt;% d3plusCoords(value = &quot;countries.topojson&quot;, projection = &quot;equirectangular&quot;) %&gt;% d3plusColor(value = &quot;Trade.Value..US..&quot;) %&gt;% d3plusTooltip(value = c(&quot;Trade.Value..US..&quot;, &quot;Partner.ISO&quot;)) %&gt;% d3plusLabels(FALSE) %&gt;% d3plusText(&quot;Partner&quot;) %&gt;% d3plusZoom(value = TRUE, scroll = FALSE) É importante que o arquivo countries.topojson esteja em um caminho relativo em relação ao endereço do html gerado pelo rmarkdown ou da pasta www de uma aplicação Shiny. rem_rais_mg_2015 &lt;- read.csv2(&#39;dados/rem_rais_mg_2015.csv&#39;) rem_rais_mg_2015$id &lt;- as.character(rem_rais_mg_2015$id) d3plus(data = rem_rais_mg_2015, type = &quot;geo_map&quot;, id = &quot;id&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, currency = &quot;R$&quot;, currency_var = &quot;mediana&quot;, number_text = c(&quot;Mil&quot;, &quot;Milhão&quot;, &quot;Milhões&quot;, &quot;Bilhão&quot;, &quot;Bilhões&quot;), elementId = &quot;mg&quot;) %&gt;% d3plusCoords(&#39;mapas/mg_munic.json&#39;, projection = &quot;equirectangular&quot;) %&gt;% d3plusLabels(FALSE) %&gt;% d3plusColor(value = &quot;mediana&quot;) %&gt;% d3plusTooltip(c(&quot;NM_MUNICIP&quot;, &quot;mediana&quot;)) %&gt;% d3plusText(&quot;NM_MUNICIP&quot;) "],
["atributos.html", " 7 Atributos 7.1 Exemplo de atributos de cores 7.2 Ícones", " 7 Atributos Cada ponto de uma visualização pode ter um conjunto de informações auxiliares que são denominadas de atributos. O mais comum é definir cores e ícones. Por exemplo, em visualização de dados exportações por fator agregado (básicos, semimanufaturados, manufaturados e operações especiais) podemos querer definir uma cor para cada fator agregado. Essa informação deve ser construída em um data.frame 7.1 Exemplo de atributos de cores O data.frame fat_attr tem uma linha para cada fator agregado, sendo um coluna com o nome do fator agregado e outra com a espeficicação da cor. Para usar os dados de atributos, devemos passar o objeto na função d3plusAttrs() e informar na função d3plusColor() o nome da coluna que possui as informações de cor. library(dplyr) library(D3plusR) dados_chn &lt;- read.csv2(&#39;dados/chn.csv&#39;, stringsAsFactors = FALSE) dados_chn_exp &lt;- dados_chn %&gt;% filter(TIPO == &quot;EXPORTAÇÕES&quot;, PERIODO == &quot;Total&quot;) fat_attr &lt;- data.frame(NO_FAT_AGREG = c(&quot;Operações Especiais&quot;, &quot;Produtos Básicos&quot;, &quot;Produtos Manufaturados&quot;, &quot;Produtos Semimanufaturados&quot;), cor = c(&quot;#C22525&quot;, &quot;#BFBF2A&quot;, &quot;#2D3C63&quot;, &quot;#A6A6A6&quot;), stringsAsFactors = FALSE) d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) %&gt;% d3plusLabels(value = TRUE, valign = &quot;top&quot;) %&gt;% d3plusAttrs(fat_attr) %&gt;% d3plusColor(&quot;cor&quot;) Agora, se o interesse da gente fosse de já apresentar os dados a nível de produto, mas separados por fator agregado (nível hierárquico superior)? Assim, criaremos um data.frame com os atributos por PPE (classificação de produtos exportados). Note que foi mantida uma coluna com o nome do nível hierárquico superior (NO_FAT_AGREG). # Evita problemas de encoding nos joins do dplyr Encoding(fat_attr$NO_FAT_AGREG) &lt;- &quot;unknown&quot; dados_chn_exp2 &lt;- left_join(dados_chn_exp, fat_attr, by = &quot;NO_FAT_AGREG&quot;) ppe_attr &lt;- dados_chn_exp2 %&gt;% select(NO_FAT_AGREG, NO_PPE_PPI, cor) %&gt;% filter(!duplicated(.)) d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) %&gt;% d3plusLabels(value = TRUE, valign = &quot;top&quot;) %&gt;% d3plusAttrs(ppe_attr) %&gt;% d3plusColor(&quot;cor&quot;) %&gt;% d3plusDepth(1) 7.1.1 Definindo atributos para os dois níveis Se quiséssemos deixar o conjunto de atributos dos dois níveis em um único objeto, poderíamos criar uma lista em que cada elemento dessa lista recebe um data.frame de atributos e é nomeado com o respectivo nome do id. fat_ppe_attr &lt;- list(NO_FAT_AGREG = fat_attr, NO_PPE_PPI = ppe_attr) d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) %&gt;% d3plusLabels(value = TRUE, valign = &quot;top&quot;) %&gt;% d3plusAttrs(fat_ppe_attr) %&gt;% d3plusColor(&quot;cor&quot;) %&gt;% d3plusDepth(1) 7.2 Ícones Para incluir ícones nas visualizações, é suficiente criar uma nova coluna com os endereços das imagens que serão usadas como ícones. Como nos mapas, é necessário que o html gerado possa acessar esses arquivos. Ou seja, não é possível visualizar os ícones em visualizações criadas diretamente para o Viewer do RStudio. fat_ppe_attr$NO_FAT_AGREG$icon &lt;- c(&#39;icons/opesp.png&#39;, &#39;icons/basicos.png&#39;, &#39;icons/manuf.png&#39;, &#39;icons/semimanuf.png&#39;) fat_ppe_attr$NO_PPE_PPI &lt;- left_join(fat_ppe_attr$NO_PPE_PPI, fat_ppe_attr$NO_FAT_AGREG, by = &quot;NO_FAT_AGREG&quot;) d3plus(dados_chn_exp, type = &quot;tree_map&quot;, id = c(&quot;NO_FAT_AGREG&quot;, &quot;NO_PPE_PPI&quot;), width = &quot;100%&quot;, height = 500) %&gt;% d3plusSize(&quot;VL_FOB&quot;) %&gt;% d3plusLabels(value = TRUE, valign = &quot;top&quot;) %&gt;% d3plusAttrs(fat_ppe_attr) %&gt;% d3plusColor(&quot;cor&quot;) %&gt;% d3plusIcon(value = &quot;icon&quot;, style = &quot;knockout&quot;) "],
["shiny.html", " 8 Shiny 8.1 Exemplo de Aplicação.", " 8 Shiny Todos os pacotes criados usando o htmlwidgets fornecem funções necessárias para criação de visualizações em aplicações shiny. O pacote D3plusR fornece duas funções: renderD3plus(): função usada no server da aplicação; d3plusOutput(): função utilizada para a interface do usuário ui. 8.1 Exemplo de Aplicação. O link para o arquivo completo da aplicação encontra-se aqui. Nesta aplicação, vamos utilizar a API fornecida pelo Comtrade/UN. Também é forcido o código para criação de uma função em R, chamada de get.comtrade(). 8.1.1 Preparação library(shiny) library(D3plusR) library(dplyr) library(tidyr) regions &lt;- read.csv(&quot;https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv&quot;, stringsAsFactors = FALSE) regions &lt;- regions %&gt;% select(alpha.3, region) %&gt;% rename(Partner.ISO = alpha.3) string &lt;- &quot;http://comtrade.un.org/data/cache/partnerAreas.json&quot; reporters &lt;- jsonlite::fromJSON(string)$results paises &lt;- reporters$id names(paises) &lt;- reporters$text get.Comtrade &lt;- function(url=&quot;https://comtrade.un.org/api/get?&quot; ,maxrec=50000 ,type=&quot;C&quot; ,freq=&quot;A&quot; ,px=&quot;HS&quot; ,ps=&quot;now&quot; ,r ,p ,rg=&quot;all&quot; ,cc=&quot;TOTAL&quot; ,fmt=&quot;json&quot; ) { string&lt;- paste(url ,&quot;max=&quot;,maxrec,&quot;&amp;&quot; #maximum no. of records returned ,&quot;type=&quot;,type,&quot;&amp;&quot; #type of trade (c=commodities) ,&quot;freq=&quot;,freq,&quot;&amp;&quot; #frequency ,&quot;px=&quot;,px,&quot;&amp;&quot; #classification ,&quot;ps=&quot;,ps,&quot;&amp;&quot; #time period ,&quot;r=&quot;,r,&quot;&amp;&quot; #reporting area ,&quot;p=&quot;,p,&quot;&amp;&quot; #partner country ,&quot;rg=&quot;,rg,&quot;&amp;&quot; #trade flow ,&quot;cc=&quot;,cc,&quot;&amp;&quot; #classification code ,&quot;fmt=&quot;,fmt #Format ,sep = &quot;&quot; ) if(fmt == &quot;csv&quot;) { raw.data&lt;- read.csv(string,header=TRUE) return(list(validation=NULL, data=raw.data)) } else { if(fmt == &quot;json&quot; ) { raw.data&lt;- rjson::fromJSON(file=string) data&lt;- raw.data$dataset validation&lt;- unlist(raw.data$validation, recursive=TRUE) ndata&lt;- NULL if(length(data)&gt; 0) { var.names&lt;- names(data[[1]]) data&lt;- as.data.frame(t( sapply(data,rbind))) ndata&lt;- NULL for(i in 1:ncol(data)){ data[sapply(data[,i],is.null),i]&lt;- NA ndata&lt;- cbind(ndata, unlist(data[,i])) } ndata&lt;- as.data.frame(ndata) colnames(ndata)&lt;- var.names } return(list(validation=validation,data =ndata)) } } } 8.1.2 Server No server, vamos apenas criar um objeto reativo (data_un) que faz a consulta na API e prepara os dados para a visualização. Com o objeto de daods pronto, adicionamos o treemap ou output (output$treemap) usando a função renderD3plus(). O código para visualização segue o padrão já tratado anteriormente. O único detalhe é que o conjunto de dados é data_un(). Ou seja, sempre que o input (seletor) for alterado, data_un() é atualizado e, consequentemente, output$treemap também é atualizado. server &lt;- function(input, output) { data_un &lt;- reactive({ existe_dados &lt;- FALSE ano &lt;- 2016 dados &lt;- data.frame() while(!existe_dados){ dados &lt;- get.Comtrade(r = input$country, p = &quot;all&quot;, ps = ano, fmt = &quot;csv&quot;)$data existe_dados &lt;- nrow(dados) &gt; 1 Sys.sleep(1.1) ano &lt;- ano - 1 } dados &lt;- dados %&gt;% filter(Partner != &quot;World&quot;, Trade.Flow %in% c(&quot;Import&quot;, &quot;Export&quot;)) %&gt;% select(Year, Trade.Flow, Reporter, Reporter.ISO, Partner, Partner.ISO, Trade.Value..US..) dados_exp &lt;- dados %&gt;% filter(Trade.Flow == &quot;Export&quot;) %&gt;% select(-Trade.Flow) %&gt;% rename(Trade_Value_Exp = Trade.Value..US..) dados_imp &lt;- dados %&gt;% filter(Trade.Flow == &quot;Import&quot;) %&gt;% select(-Trade.Flow) %&gt;% rename(Trade_Value_Imp = Trade.Value..US..) dados &lt;- full_join(dados_exp, dados_imp) %&gt;% replace_na(list(Trade_Value_Exp = 0, Trade_Value_Imp = 0)) dados &lt;- dados %&gt;% left_join(regions) %&gt;% replace_na(list(region = &quot;Not Specified&quot;)) %&gt;% mutate(region = ifelse(region == &quot;&quot;, &quot;Not Specified&quot;, region)) }) output$treemap &lt;- renderD3plus({ toggle_button &lt;- list(list(Exports = &quot;Trade_Value_Exp&quot;), list(Imports = &quot;Trade_Value_Imp&quot;)) ano &lt;- max(data_un()$Year) title &lt;- paste0(&quot;Trade by Partners - &quot;, reporters$text[reporters$id == input$country], &quot; - &quot;, ano) d3plus(data_un(), type = &quot;tree_map&quot;, id = c(&quot;region&quot;, &quot;Partner&quot;), currency_var = c(&quot;Trade_Value_Exp&quot;, &quot;Trade_Value_Imp&quot;), locale = &quot;pt_BR&quot;) %&gt;% d3plusSize(&quot;Trade_Value_Exp&quot;) %&gt;% d3plusUi(list(method = &quot;size&quot;, type = &quot;toggle&quot;, label = &quot;Trade Flow: &quot;, value = toggle_button)) %&gt;% d3plusColor(&quot;region&quot;) %&gt;% d3plusDepth(1) %&gt;% d3plusTitle(value = title, font = list(size = 22, weight = 900), total = list(value = list(prefix = &quot;Total: &quot;), font = list(size = 16, weight = 900))) %&gt;% d3plusFooter(value = &quot;Source: UN/Comtrade.&quot;, font = list(align = &quot;left&quot;)) }) } 8.1.3 UI Para apresentação da visualização na aplicação, utiliza-se a função d3plusOutput com o nome do elemento que definimos no server. Ou seja, treemap. ui &lt;- fluidPage( fluidRow( column(2), column(8, h1(&quot;Exports and Imports by Country&quot;, align = &quot;center&quot;) ) ), fluidRow( column(2), column(8, selectInput(&quot;country&quot;, label = &quot;Select a reporter:&quot;, choices = paises, selected = &quot;76&quot;, multiple = FALSE) ) ), fluidRow( column(2), column(8, d3plusOutput(&#39;treemap&#39;, height = 600) ) ) ) 8.1.4 Código completo library(shiny) library(D3plusR) library(dplyr) library(tidyr) regions &lt;- read.csv(&quot;https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv&quot;, stringsAsFactors = FALSE) regions &lt;- regions %&gt;% select(alpha.3, region) %&gt;% rename(Partner.ISO = alpha.3) string &lt;- &quot;http://comtrade.un.org/data/cache/partnerAreas.json&quot; reporters &lt;- jsonlite::fromJSON(string)$results paises &lt;- reporters$id names(paises) &lt;- reporters$text get.Comtrade &lt;- function(url=&quot;https://comtrade.un.org/api/get?&quot; ,maxrec=50000 ,type=&quot;C&quot; ,freq=&quot;A&quot; ,px=&quot;HS&quot; ,ps=&quot;now&quot; ,r ,p ,rg=&quot;all&quot; ,cc=&quot;TOTAL&quot; ,fmt=&quot;json&quot; ) { string&lt;- paste(url ,&quot;max=&quot;,maxrec,&quot;&amp;&quot; #maximum no. of records returned ,&quot;type=&quot;,type,&quot;&amp;&quot; #type of trade (c=commodities) ,&quot;freq=&quot;,freq,&quot;&amp;&quot; #frequency ,&quot;px=&quot;,px,&quot;&amp;&quot; #classification ,&quot;ps=&quot;,ps,&quot;&amp;&quot; #time period ,&quot;r=&quot;,r,&quot;&amp;&quot; #reporting area ,&quot;p=&quot;,p,&quot;&amp;&quot; #partner country ,&quot;rg=&quot;,rg,&quot;&amp;&quot; #trade flow ,&quot;cc=&quot;,cc,&quot;&amp;&quot; #classification code ,&quot;fmt=&quot;,fmt #Format ,sep = &quot;&quot; ) if(fmt == &quot;csv&quot;) { raw.data&lt;- read.csv(string,header=TRUE) return(list(validation=NULL, data=raw.data)) } else { if(fmt == &quot;json&quot; ) { raw.data&lt;- rjson::fromJSON(file=string) data&lt;- raw.data$dataset validation&lt;- unlist(raw.data$validation, recursive=TRUE) ndata&lt;- NULL if(length(data)&gt; 0) { var.names&lt;- names(data[[1]]) data&lt;- as.data.frame(t( sapply(data,rbind))) ndata&lt;- NULL for(i in 1:ncol(data)){ data[sapply(data[,i],is.null),i]&lt;- NA ndata&lt;- cbind(ndata, unlist(data[,i])) } ndata&lt;- as.data.frame(ndata) colnames(ndata)&lt;- var.names } return(list(validation=validation,data =ndata)) } } } # Define UI for application that draws a histogram ui &lt;- fluidPage( fluidRow( column(2), column(8, h1(&quot;Exports and Imports by Country&quot;, align = &quot;center&quot;) ) ), fluidRow( column(2), column(8, selectInput(&quot;country&quot;, label = &quot;Select a reporter:&quot;, choices = paises, selected = &quot;76&quot;, multiple = FALSE) ) ), fluidRow( column(2), column(8, d3plusOutput(&#39;treemap&#39;, height = 600) ) ) ) # Define server logic required to draw a histogram server &lt;- function(input, output) { data_un &lt;- reactive({ existe_dados &lt;- FALSE ano &lt;- 2016 dados &lt;- data.frame() while(!existe_dados){ dados &lt;- get.Comtrade(r = input$country, p = &quot;all&quot;, ps = ano, fmt = &quot;csv&quot;)$data existe_dados &lt;- nrow(dados) &gt; 1 Sys.sleep(1.1) ano &lt;- ano - 1 } dados &lt;- dados %&gt;% filter(Partner != &quot;World&quot;, Trade.Flow %in% c(&quot;Import&quot;, &quot;Export&quot;)) %&gt;% select(Year, Trade.Flow, Reporter, Reporter.ISO, Partner, Partner.ISO, Trade.Value..US..) dados_exp &lt;- dados %&gt;% filter(Trade.Flow == &quot;Export&quot;) %&gt;% select(-Trade.Flow) %&gt;% rename(Trade_Value_Exp = Trade.Value..US..) dados_imp &lt;- dados %&gt;% filter(Trade.Flow == &quot;Import&quot;) %&gt;% select(-Trade.Flow) %&gt;% rename(Trade_Value_Imp = Trade.Value..US..) dados &lt;- full_join(dados_exp, dados_imp) %&gt;% replace_na(list(Trade_Value_Exp = 0, Trade_Value_Imp = 0)) dados &lt;- dados %&gt;% left_join(regions) %&gt;% replace_na(list(region = &quot;Not Specified&quot;)) %&gt;% mutate(region = ifelse(region == &quot;&quot;, &quot;Not Specified&quot;, region)) }) output$treemap &lt;- renderD3plus({ toggle_button &lt;- list(list(Exports = &quot;Trade_Value_Exp&quot;), list(Imports = &quot;Trade_Value_Imp&quot;)) ano &lt;- max(data_un()$Year) title &lt;- paste0(&quot;Trade by Partners - &quot;, reporters$text[reporters$id == input$country], &quot; - &quot;, ano) d3plus(data_un(), type = &quot;tree_map&quot;, id = c(&quot;region&quot;, &quot;Partner&quot;), currency_var = c(&quot;Trade_Value_Exp&quot;, &quot;Trade_Value_Imp&quot;), locale = &quot;pt_BR&quot;) %&gt;% d3plusSize(&quot;Trade_Value_Exp&quot;) %&gt;% d3plusUi(list(method = &quot;size&quot;, type = &quot;toggle&quot;, label = &quot;Trade Flow: &quot;, value = toggle_button)) %&gt;% d3plusColor(&quot;region&quot;) %&gt;% d3plusDepth(1) %&gt;% d3plusTitle(value = title, font = list(size = 22, weight = 900), total = list(value = list(prefix = &quot;Total: &quot;), font = list(size = 16, weight = 900))) %&gt;% d3plusFooter(value = &quot;Source: UN/Comtrade.&quot;, font = list(align = &quot;left&quot;)) }) } # Run the application shinyApp(ui = ui, server = server) "],
["adicionando-codigo-javascript.html", " 9 Adicionando código JavaScript 9.1 Código JavaScript após a renderização", " 9 Adicionando código JavaScript Muitas vezes pode ser que o pacote criado para o R não forneça todas as opções disponíveis na biblioteca original. Para não limitar os usuários, o pacote htmlwidgets fornece uma função, onRender(), em que o usuário pode adicionar código em JavaScript para complementar a criação da visualização. Para isso, o usuário deve conhecer a biblioteca original. library(dplyr) library(D3plusR) library(htmlwidgets) dados &lt;- read.csv(&#39;dados/exp_imp_brasil.csv&#39;) d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, noformat_number_var = &quot;CO_ANO&quot;, elementId = &quot;chart1&quot;) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, label = &quot;Ano&quot;) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, label = &quot;Valor FOB&quot;) %&gt;% onRender(&#39;function(el, x, data){ var viz = this.viz; viz.mouse({&quot;click&quot;: function(d){ viz.id({&quot;solo&quot;: d.TIPO}).draw(); } }) }&#39;) 9.1 Código JavaScript após a renderização A função onRender() executa o código JavaScript no modelo da renderização de cada widget. Ou seja, nao existe possibilidade de encontrar um widget que ainda não foi criado e realizar interações. Para que um widget se comunique com outro, podemos usar a função onStaticRenderComplete(). Primeiro vamos criar uma segunda visualização: d3plus(data = dados %&gt;% filter(CO_ANO &gt;= 2005), type = &quot;bar&quot;, id = &quot;TIPO&quot;, width = &quot;100%&quot;, height = 500, locale = &quot;pt_BR&quot;, noformat_number_var = &quot;CO_ANO&quot;, elementId = &quot;chart2&quot;) %&gt;% d3plusX(value = &quot;CO_ANO&quot;, label = &quot;Ano&quot;) %&gt;% d3plusY(value = &quot;VL_FOB&quot;, label = &quot;Valor FOB&quot;) Agora, vamos usar a função onStaticRenderComplete(). Dentro dela passaremos o código JavaScript que será responsável pela interação entre as visualizações. Precisamos criar dois objetos com as duas visualizações criadas anteriormente. Para isso, usaremos o HTMLWidgets.find() que é disponibilizada pela framework do htmlwidgets. Basicamente, buscamos a visualização pelo nome da Id que demos quando elas foram criadas. No caso, chart1 e chart2. onStaticRenderComplete(&#39; var chart1 = HTMLWidgets.find(&quot;#chart1&quot;).viz; var chart2 = HTMLWidgets.find(&quot;#chart2&quot;).viz; chart1.mouse({&quot;click&quot;: function(d){ chart2.id({&quot;solo&quot;: d.TIPO}).draw(); chart1.id({&quot;solo&quot;: d.TIPO}).draw(); }}) chart2.mouse({&quot;click&quot;: function(d){ chart2.id({&quot;solo&quot;: d.TIPO}).draw(); chart1.id({&quot;solo&quot;: d.TIPO}).draw(); }})&#39;) "]
]
